if (secrets.midjourneyApiKey == "" || secrets.midjourneyApiKey == undefined) {
  throw Error("MIDJOURNEY_API_KEY NOT SET")
}

if (secrets.nftStorageApiKey == "" || secrets.nftStorageApiKey == undefined) {
  throw Error("NFT_STORAGE_API_KEY NOT SET")
}

const BASE_URL = "https://api.thenextleg.io/v2"
const AUTH_TOKEN = secrets.midjourneyApiKey
const AUTH_HEADERS = {
  Authorization: `Bearer ${AUTH_TOKEN}`,
  "Content-Type": "application/json",
}

const type = args[0]
if (type == "NEW_BORN") {
  const rarityNumber = args[1]
  const seed = args[2]
  const tokenId = args[3]

  const rarity = getRarity(rarityNumber)

  const outputsResponse = await Functions.makeHttpRequest({
    url: `${BASE_URL}/message/${seed}`,
    method: "GET",
    headers: AUTH_HEADERS,
  })

  console.log(outputsResponse)

  if (outputsResponse.data == undefined && outputsResponse.error == undefined) {
    throw Error("Invalid seed")
  }

  if (outputsResponse.error) {
    throw Error("API Failed")
  }

  const imageUrl = outputsResponse.data.response.imageUrls[0]

  const prompt = outputsResponse.data.response.content

  console.log(imageUrl)

  // const modifiedImageUrl = await storeImageInIPFS(imageUrl)

  // console.log(modifiedImageUrl)

  const metadata = {
    name: "ZexNFTs#" + tokenId,
    description: "A freshly created and zex crafted NFT that is generated with a prompt using Midjourney AI",
    image: imageUrl,
    attributes: [
      {
        trait_type: "type",
        value: type,
      },
      {
        trait_type: "originChain",
        value: "avalancheFuji",
      },
      {
        trait_type: "prompt",
        value: prompt,
      },
      {
        trait_type: "kind",
        value: rarity.name,
      },
      {
        trait_type: "rarity",
        value: rarityNumber,
      },
    ],
  }
  const metadataString = JSON.stringify(metadata, null, 2)

  console.log(metadataString)

  return await storeInIPFS(metadataString)
} else {
  const nft1TokenURI = args[1]
  const nft1ChainSelector = args[2]
  const nft2TokenURI = args[3]
  const nft2ChainSelector = args[4]
  const rarityNumber = args[5]
  const seed = args[6]
  const tokenId = args[7]

  const nft1MetadataRequest = Functions.makeHttpRequest({
    url: nft1TokenURI,
    method: "GET",
    headers: { "Content-Type": "application/json" },
  })

  const nft2MetadataRequest = Functions.makeHttpRequest({
    url: nft2TokenURI,
    method: "GET",
    headers: { "Content-Type": "application/json" },
  })

  const [nft1MetadataResponse, nft2MetadataResponse] = await Promise.all([nft1MetadataRequest, nft2MetadataRequest])

  if (nft1MetadataResponse.error) {
    throw Error("NFT1 Metadata Fetch Failed")
  }

  if (nft2MetadataResponse.error) {
    throw Error("NFT2 Metadata Fetch Failed")
  }

  const nft1Metadata = nft1MetadataResponse.data
  const nft2Metadata = nft2MetadataResponse.data

  const rarity = getRarity(rarityNumber)

  // console.log(modifiedPrompt)
  const outputsResponse = await Functions.makeHttpRequest({
    url: `${BASE_URL}/message/${seed}`,
    method: "GET",
    headers: AUTH_HEADERS,
  })

  if (outputsResponse.data == undefined && outputsResponse.error == undefined) {
    throw Error("Invalid seed")
  }
  if (outputsResponse.error) {
    throw Error("MidJourney outputs fetch Failed")
  }
  const imageUrl = outputsResponse.data.response.imageUrls[0]

  const modifiedPrompt = outputsResponse.data.response.content

  console.log(imageUrl)

  // const modifiedImageUrl = await storeImageInIPFS(imageUrl)

  // console.log(modifiedImageUrl)

  const metadata = {
    name: "ZexNFTs#" + tokenId,
    description: "A zexcrafted NFT that is generated by combining the two parents NFTs using Midjourney AI",
    image: imageUrl,
    attributes: [
      {
        trait_type: "type",
        value: type,
      },
      {
        trait_type: "nft1_name",
        value: nft1Metadata.name,
      },
      {
        trait_type: "nft2_name",
        value: nft2Metadata.name,
      },
      {
        trait_type: "nft1_image",
        value: nft1Metadata.image,
      },
      {
        trait_type: "nft2_image",
        value: nft2Metadata.image,
      },
      {
        trait_type: "nft1_chain",
        value: getChain(nft1ChainSelector),
      },
      {
        trait_type: "nft2_chain",
        value: getChain(nft2ChainSelector),
      },
      {
        trait_type: "kind",
        value: rarity.name,
      },
      {
        trait_type: "rarity",
        value: rarityNumber,
      },
      {
        trait_type: "prompt",
        value: modifiedPrompt,
      },
    ],
  }
  const metadataString = JSON.stringify(metadata, null, 2)
  console.log(metadataString)
  return await storeInIPFS(metadataString)
}

async function storeInIPFS(metadataString) {
  const storeMetadataRequest = Functions.makeHttpRequest({
    url: `https://zixins-be1.adaptable.app/auth/store`,
    method: "POST",
    headers: { Authorization: `Bearer ${secrets.nftStorageApiKey}`, "Content-Type": "application/json" },
    data: { metadataString: metadataString },
  })
  const [storeMetadataResponse] = await Promise.all([storeMetadataRequest])
  console.log(storeMetadataResponse)

  if (!storeMetadataResponse.error) {
    const metadataUrl = "https://" + storeMetadataResponse.data.value.cid + ".ipfs.nftstorage.link/metadata.json"
    console.log("Returning url: " + metadataUrl)
    return Functions.encodeString(metadataUrl)
  } else {
    throw Error(storeMetadataResponse.data)
  }
}

async function storeImageInIPFS(imageUrl) {
  console.log("Requesting image: ", { image: imageUrl })
  const storeImageRequest = Functions.makeHttpRequest({
    url: `https://zixins-be1.adaptable.app/auth/image`,
    method: "POST",
    headers: { Authorization: `Bearer ${secrets.nftStorageApiKey}`, "Content-Type": "application/json" },
    data: { image: imageUrl },
  })
  const [storeImageResponse] = await Promise.all([storeImageRequest])
  console.log("Image Response: ")
  console.log(storeImageResponse)

  if (!storeImageResponse.error) {
    const imageUrl = "https://" + storeImageResponse.data.value.cid + ".ipfs.nftstorage.link/image.jpg"
    console.log("Returning url: " + imageUrl)
    return imageUrl
  } else {
    throw Error(storeImageResponse.data)
  }
}

function getRarity(rarity) {
  if (rarity < 30) {
    return { name: "COMMON", color: "GREY" }
  } else if (rarity < 60) {
    return { name: "UNCOMMON", color: "GREEN" }
  } else if (rarity < 70) {
    return { name: "RARE", color: "BLUE" }
  } else if (rarity < 85) {
    return { name: "EPIC", color: "PURPLE" }
  } else if (rarity < 95) {
    return { name: "LEGENDARY", color: "GOLDEN" }
  } else if (rarity < 100) {
    return { name: "ZEXSTAR", color: "RED" }
  } else {
    return { name: "SPECIAL EDITION", color: "PINK" }
  }
}

function getChain(chainSelector) {
  if (chainSelector == "16015286601757825753") {
    return "sepolia"
  } else if (chainSelector == "2664363617261496610") {
    return "optimismGoerli"
  } else if (chainSelector == "12532609583862916517") {
    return "polygonMumbai"
  } else if (chainSelector == "14767482510784806043") {
    return "avalancheFuji"
  } else if (chainSelector == "13264668187771770619") {
    return "avalancheMainnet"
  } else if (chainSelector == "5790810961207155433") {
    return "baseGoerli"
  } else {
    return "unknown"
  }
}
